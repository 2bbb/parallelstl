/*
    Copyright (c) 2017-2018 Intel Corporation

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.




*/

#ifndef __PSTL_algorithm
#define __PSTL_algorithm

#include <functional>

#include "internal/pstl_config.h"
#include "internal/utils.h"
#include "internal/algorithm_impl.h"
#include "internal/numeric_impl.h"  /* count and count_if use pattern_transform_reduce */

namespace std {

// [alg.any_of]

template<class ExecutionPolicy, class InputIterator, class Predicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
any_of(ExecutionPolicy&& exec, InputIterator first, InputIterator last, Predicate pred) {
    using namespace pstl::internal;
    return pattern_any_of( first, last, pred,
        is_vectorization_preferred<ExecutionPolicy,InputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy,InputIterator>(exec));
}

// [alg.all_of]

template<class ExecutionPolicy, class InputIterator, class Pred>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
all_of(ExecutionPolicy&& exec, InputIterator first, InputIterator last, Pred pred) {
    return !any_of(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::not_pred<Pred>(pred));
}

// [alg.none_of]

template<class ExecutionPolicy, class InputIterator, class Predicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
none_of(ExecutionPolicy&& exec, InputIterator first, InputIterator last, Predicate pred) {
    return !any_of( std::forward<ExecutionPolicy>(exec), first, last, pred );
}

// [alg.foreach]

template<class ExecutionPolicy, class InputIterator, class Function>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
for_each(ExecutionPolicy&& exec, InputIterator first, InputIterator last, Function f) {
    using namespace pstl::internal;
    pattern_walk1(
        first, last, f,
        is_vectorization_preferred<ExecutionPolicy,InputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy,InputIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator, class Size, class Function>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, InputIterator>
for_each_n(ExecutionPolicy&& exec, InputIterator first, Size n, Function f) {
    using namespace pstl::internal;
    return pattern_walk1_n(first, n, f,
        is_vectorization_preferred<ExecutionPolicy,InputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy,InputIterator>(exec));
}

// [alg.find]

template<class ExecutionPolicy, class ForwardIterator, class Predicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
find_if(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Predicate pred) {
    using namespace pstl::internal;
    return pattern_find_if( first, last, pred,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template<class ExecutionPolicy, class ForwardIterator, class Predicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
find_if_not(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
Predicate pred) {
    return find_if(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::not_pred<Predicate>(pred));
}

template<class ExecutionPolicy, class ForwardIterator, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
find(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last,
const T& value) {
    return find_if(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::equal_value<T>(value));
}

// [alg.find.end]
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator1>
find_end(ExecutionPolicy &&exec, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 s_first, ForwardIterator2 s_last, BinaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_find_end(first, last, s_first, s_last, pred,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator1, ForwardIterator2>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator1, ForwardIterator2>(exec));
}

template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator1>
find_end(ExecutionPolicy&& exec, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 s_first, ForwardIterator2 s_last) {
    return find_end(std::forward<ExecutionPolicy>(exec), first, last, s_first, s_last, pstl::internal::pstl_equal());
}

// [alg.find_first_of]
template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator1>
find_first_of(ExecutionPolicy&& exec, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 s_first, ForwardIterator2 s_last, BinaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_find_first_of(first, last, s_first, s_last, pred,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator1, ForwardIterator2>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator1, ForwardIterator2>(exec));
}

template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator1>
find_first_of(ExecutionPolicy&& exec, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 s_first, ForwardIterator2 s_last) {
    return find_first_of(std::forward<ExecutionPolicy>(exec), first, last, s_first, s_last, pstl::internal::pstl_equal());
}

// [alg.adjacent_find]
template< class ExecutionPolicy, class ForwardIt >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIt>
adjacent_find(ExecutionPolicy&& exec, ForwardIt first, ForwardIt last) {
    using namespace pstl::internal;
    return pattern_adjacent_find(first, last, pstl::internal::pstl_equal(),
       is_parallelization_preferred<ExecutionPolicy, ForwardIt>(exec),
       is_vectorization_preferred<ExecutionPolicy, ForwardIt>(exec), /*first_semantic*/ false);
}

template< class ExecutionPolicy, class ForwardIt, class BinaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIt>
adjacent_find(ExecutionPolicy&& exec, ForwardIt first, ForwardIt last, BinaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_adjacent_find(first, last, pred,
       is_parallelization_preferred<ExecutionPolicy, ForwardIt>(exec),
       is_vectorization_preferred<ExecutionPolicy, ForwardIt>(exec), /*first_semantic*/ false);
}

// [alg.count]

// Implementation note: count and count_if call the pattern directly instead of calling std::transform_reduce
// so that we do not have to include <numeric>.

template<class ExecutionPolicy, class ForwardIterator, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,typename iterator_traits<ForwardIterator>::difference_type>
count(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, const T& value) {
    typedef typename iterator_traits<ForwardIterator>::reference value_type;
    using namespace pstl::internal;
    return pattern_count(first, last, [&value](const value_type x) {return value==x;},
       is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec),
       is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template<class ExecutionPolicy, class ForwardIterator, class Predicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,typename iterator_traits<ForwardIterator>::difference_type>
count_if(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Predicate pred) {
    using namespace pstl::internal;
    return pattern_count(first, last, pred,
       is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec),
       is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

// [alg.search]

template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator1>
search(ExecutionPolicy&& exec, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 s_first, ForwardIterator2 s_last, BinaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_search(first, last, s_first, s_last, pred,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator1, ForwardIterator2>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator1, ForwardIterator2>(exec));
}

template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator1>
search(ExecutionPolicy&& exec, ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 s_first, ForwardIterator2 s_last) {
    return search(std::forward<ExecutionPolicy>(exec), first, last, s_first, s_last, pstl::internal::pstl_equal());
}

template<class ExecutionPolicy, class ForwardIterator, class Size, class T, class BinaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
search_n(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Size count, const T& value, BinaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_search_n(first, last, count, value, pred,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template<class ExecutionPolicy, class ForwardIterator, class Size, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
search_n(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Size count, const T& value) {
    return search_n(std::forward<ExecutionPolicy>(exec), first, last, count, value, pstl::internal::pstl_equal());
}

// [alg.copy]

template<class ExecutionPolicy, class InputIterator, class OutputIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,OutputIterator>
copy(ExecutionPolicy&& exec, InputIterator first, InputIterator last, OutputIterator result) {
    using namespace pstl::internal;
    const auto is_vector = is_vectorization_preferred<ExecutionPolicy, InputIterator, OutputIterator>(exec);

    return pattern_walk2_brick(first, last, result, [is_vector](InputIterator begin, InputIterator end, OutputIterator res){
        return brick_copy(begin, end, res, is_vector);
    }, is_parallelization_preferred<ExecutionPolicy, InputIterator, OutputIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator, class Size, class OutputIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,OutputIterator>
copy_n(ExecutionPolicy&& exec, InputIterator first, Size n, OutputIterator result) {
    using namespace pstl::internal;
    const auto is_vector = is_vectorization_preferred<ExecutionPolicy, InputIterator, OutputIterator>(exec);

    return pattern_walk2_brick_n(first, n, result, [is_vector](InputIterator begin, Size sz, OutputIterator res){
        return brick_copy_n(begin, sz, res, is_vector);
    }, is_parallelization_preferred<ExecutionPolicy, InputIterator, OutputIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator, class OutputIterator, class Predicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,OutputIterator>
copy_if(ExecutionPolicy&& exec,
        InputIterator first, InputIterator last,
        OutputIterator result, Predicate pred) {
    using namespace pstl::internal;
    return pattern_copy_if(
        first, last, result, pred,
        is_vectorization_preferred<ExecutionPolicy,InputIterator,OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy,InputIterator,OutputIterator>(exec));
}

// [alg.swap]

template<class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator2>
swap_ranges(ExecutionPolicy&& exec, ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2) {
    using namespace pstl::internal;
    return pattern_swap_ranges(first1, last1, first2,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator1, ForwardIterator2>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator1, ForwardIterator2>(exec));
}

// [alg.transform]

template<class ExecutionPolicy, class InputIterator, class OutputIterator, class UnaryOperation>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,OutputIterator>
transform( ExecutionPolicy&& exec, InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op ) {
    typedef typename iterator_traits<InputIterator>::reference input_type;
    typedef typename iterator_traits<OutputIterator>::reference output_type;
    using namespace pstl::internal;
    return pattern_walk2(first, last, result,
        [op](input_type x, output_type y ) mutable { y = op(x);},
        is_vectorization_preferred<ExecutionPolicy,InputIterator,OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy,InputIterator,OutputIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,OutputIterator>
transform( ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryOperation op ) {
    typedef typename iterator_traits<InputIterator1>::reference input1_type;
    typedef typename iterator_traits<InputIterator2>::reference input2_type;
    typedef typename iterator_traits<OutputIterator>::reference output_type;
    using namespace pstl::internal;
    return pattern_walk3(first1, last1, first2, result, [op](input1_type x, input2_type y, output_type z ) mutable {z = op(x,y);},
        is_vectorization_preferred<ExecutionPolicy,InputIterator1,InputIterator2,OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy,InputIterator1,InputIterator2,OutputIterator>(exec));
}

// [alg.replace]

template<class ExecutionPolicy, class ForwardIterator, class UnaryPredicate, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
replace_if(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T& new_value) {
    using namespace pstl::internal;
    typedef typename iterator_traits<ForwardIterator>::reference element_type;
    pattern_walk1(first, last, [&pred, &new_value] (element_type elem) {
            if (pred(elem)) {
                elem = new_value;
            }
        },
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template<class ExecutionPolicy, class ForwardIterator, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
replace(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value) {
    replace_if(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::equal_value<T>(old_value), new_value);
}

template<class ExecutionPolicy, class InputIterator, class OutputIterator, class UnaryPredicate, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
replace_copy_if(ExecutionPolicy&& exec, InputIterator first, InputIterator last, OutputIterator result, UnaryPredicate pred, const T& new_value) {
    typedef typename iterator_traits<InputIterator>::reference input_type;
    typedef typename iterator_traits<OutputIterator>::reference output_type;
    using namespace pstl::internal;
    return pattern_walk2(
        first, last, result,
        [pred, &new_value](input_type x, output_type y) mutable { y = pred(x) ? new_value : x; },
        is_vectorization_preferred<ExecutionPolicy, InputIterator, OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator, OutputIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator, class OutputIterator, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
replace_copy(ExecutionPolicy&& exec, InputIterator first, InputIterator last, OutputIterator result, const T& old_value, const T& new_value) {
    return replace_copy_if(std::forward<ExecutionPolicy>(exec), first, last, result, pstl::internal::equal_value<T>(old_value), new_value);
}

// [alg.fill]

template <class ExecutionPolicy, class ForwardIterator, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
fill( ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, const T& value ) {
    using namespace pstl::internal;
    pattern_fill(first, last, value,
        is_parallelization_preferred<ExecutionPolicy,ForwardIterator>(exec),
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template< class ExecutionPolicy, class OutputIterator, class Size, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
fill_n( ExecutionPolicy&& exec, OutputIterator first, Size count, const T& value ) {
    if(count <= 0)
        return first;

    using namespace pstl::internal;
    return pattern_fill_n(first, count, value,
        is_parallelization_preferred<ExecutionPolicy, OutputIterator>(exec),
        is_vectorization_preferred<ExecutionPolicy, OutputIterator>(exec));
}

// [alg.generate]
template< class ExecutionPolicy, class ForwardIterator, class Generator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
generate( ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Generator g ) {
    using namespace pstl::internal;
    pattern_generate(first, last, g,
        is_parallelization_preferred<ExecutionPolicy,ForwardIterator>(exec),
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template< class ExecutionPolicy, class OutputIterator, class Size, class Generator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
generate_n( ExecutionPolicy&& exec, OutputIterator first, Size count, Generator g ) {
    if(count <= 0)
        return first;

    using namespace pstl::internal;
    return pattern_generate_n(first, count, g,
        is_parallelization_preferred<ExecutionPolicy, OutputIterator>(exec),
        is_vectorization_preferred<ExecutionPolicy, OutputIterator>(exec));
}

// [alg.remove]

template<class ExecutionPolicy, class InputIterator, class OutputIterator, class Predicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,OutputIterator>
remove_copy_if(ExecutionPolicy&& exec, InputIterator first, InputIterator last, OutputIterator result, Predicate pred) {
    return copy_if(std::forward<ExecutionPolicy>(exec), first, last, result, pstl::internal::not_pred<Predicate>(pred));
}

template<class ExecutionPolicy, class InputIterator, class OutputIterator, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,OutputIterator>
remove_copy(ExecutionPolicy&& exec, InputIterator first, InputIterator last, OutputIterator result, const T& value) {
    return copy_if(std::forward<ExecutionPolicy>(exec), first, last, result, pstl::internal::not_equal_value<T>(value));
}

template<class ExecutionPolicy, class ForwardIterator, class UnaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
remove_if(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, UnaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_remove_if(first, last, pred,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template<class ExecutionPolicy, class ForwardIterator, class T>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
remove(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, const T& value) {
    return remove_if(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::equal_value<T>(value));
}

// [alg.unique]

template<class ExecutionPolicy, class ForwardIterator, class BinaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
unique(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, BinaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_unique(first, last, pred,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template<class ExecutionPolicy, class ForwardIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
unique(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last) {
    return unique(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::pstl_equal());
}

template<class ExecutionPolicy, class InputIterator, class OutputIterator, class BinaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,OutputIterator>
unique_copy(ExecutionPolicy&& exec, InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_unique_copy(first, last, result, pred,
        is_vectorization_preferred<ExecutionPolicy,InputIterator,OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy,InputIterator,OutputIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator, class OutputIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy,OutputIterator>
unique_copy(ExecutionPolicy&& exec, InputIterator first, InputIterator last, OutputIterator result) {
    return unique_copy(std::forward<ExecutionPolicy>(exec), first, last, result, pstl::internal::pstl_equal() );
}

// [alg.reverse]

template<class ExecutionPolicy, class BidirectionalIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
reverse(ExecutionPolicy&& exec, BidirectionalIterator first, BidirectionalIterator last) {
    using namespace pstl::internal;
    pattern_reverse(first, last,
        is_vectorization_preferred<ExecutionPolicy, BidirectionalIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, BidirectionalIterator>(exec));
}

template<class ExecutionPolicy, class BidirectionalIterator, class OutputIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
reverse_copy(ExecutionPolicy&& exec, BidirectionalIterator first, BidirectionalIterator last, OutputIterator d_first) {
    using namespace pstl::internal;
    return pattern_reverse_copy(first, last, d_first,
        is_vectorization_preferred<ExecutionPolicy, BidirectionalIterator, OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, BidirectionalIterator, OutputIterator>(exec));
}

// [alg.rotate]

template<class ExecutionPolicy, class ForwardIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
rotate(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator middle, ForwardIterator last) {
    using namespace pstl::internal;
    return pattern_rotate(first, middle, last,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template<class ExecutionPolicy, class ForwardIterator, class OutputIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
rotate_copy(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result) {
    using namespace pstl::internal;
    return pattern_rotate_copy(first, middle, last, result,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator, OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator, OutputIterator>(exec));
}

// [alg.partitions]

template<class ExecutionPolicy, class InputIterator, class UnaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
is_partitioned(ExecutionPolicy&& exec, InputIterator first, InputIterator last, UnaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_is_partitioned(first, last, pred,
        is_vectorization_preferred<ExecutionPolicy, InputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator>(exec));
}

template<class ExecutionPolicy, class ForwardIterator, class UnaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
partition(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, UnaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_partition(first, last, pred,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template<class ExecutionPolicy, class BidirectionalIterator, class UnaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, BidirectionalIterator>
stable_partition(ExecutionPolicy&& exec, BidirectionalIterator first, BidirectionalIterator last, UnaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_stable_partition(first, last, pred,
        is_vectorization_preferred<ExecutionPolicy, BidirectionalIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, BidirectionalIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator, class OutputIterator1, class OutputIterator2, class UnaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, std::pair<OutputIterator1, OutputIterator2>>
partition_copy(ExecutionPolicy&& exec, InputIterator first, InputIterator last, OutputIterator1 out_true, OutputIterator2 out_false, UnaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_partition_copy(first, last, out_true, out_false, pred,
        is_vectorization_preferred<ExecutionPolicy, InputIterator, OutputIterator1, OutputIterator2>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator, OutputIterator1, OutputIterator2>(exec));
}

// [alg.sort]

template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
sort(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
    typedef typename iterator_traits<RandomAccessIterator>::value_type input_type;
    using namespace pstl::internal;
    return pattern_sort(first, last, comp,
        is_vectorization_preferred<ExecutionPolicy,RandomAccessIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy,RandomAccessIterator>(exec),
        typename std::is_move_constructible<input_type>::type());
}

template<class ExecutionPolicy, class RandomAccessIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
sort(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator last) {
    sort(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::pstl_less());
}

// [stable.sort]

template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
stable_sort(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
    using namespace pstl::internal;
    return pattern_stable_sort(first, last, comp,
        is_vectorization_preferred<ExecutionPolicy,RandomAccessIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy,RandomAccessIterator>(exec));
}

template<class ExecutionPolicy, class RandomAccessIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
stable_sort(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator last) {
    stable_sort(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::pstl_less());
}

// [mismatch]

template< class ExecutionPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, std::pair<InputIterator1, InputIterator2>>
mismatch(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate pred) {
    using namespace pstl::internal;
    return pattern_mismatch(first1, last1, first2, last2, pred,
        is_vectorization_preferred<ExecutionPolicy, InputIterator1, InputIterator2>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator1, InputIterator2>(exec));
}

template< class ExecutionPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, std::pair<InputIterator1, InputIterator2>>
mismatch(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate pred) {
    return mismatch(std::forward<ExecutionPolicy>(exec), first1, last1, first2, std::next(first2, std::distance(first1, last1)), pred);
}

template< class ExecutionPolicy, class InputIterator1, class InputIterator2 >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, std::pair<InputIterator1, InputIterator2>>
mismatch(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2) {
    return mismatch(std::forward<ExecutionPolicy>(exec), first1, last1, first2, last2, pstl::internal::pstl_equal());
}

template< class ExecutionPolicy, class InputIterator1, class InputIterator2 >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, std::pair<InputIterator1, InputIterator2>>
mismatch(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2) {
    return mismatch(std::forward<ExecutionPolicy>(exec), first1, last1, first2, std::next(first2, std::distance(first1, last1)));
}

// [alg.equal]

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
equal(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, BinaryPredicate p) {
    using namespace pstl::internal;
    return pattern_equal(first1, last1, first2, p,
        is_vectorization_preferred<ExecutionPolicy, InputIterator1>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator1>(exec)
        );
}

template<class ExecutionPolicy, class InputIterator1, class InputIterator2>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
equal(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2) {
    return equal(std::forward<ExecutionPolicy>(exec), first1, last1, first2, pstl::internal::pstl_equal());
}

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class BinaryPredicate>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
equal(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, BinaryPredicate p) {
    if ( std::distance(first1, last1) == std::distance(first2, last2) )
        return std::equal(first1, last1, first2, p);
    else
        return false;
}

template<class ExecutionPolicy, class InputIterator1, class InputIterator2>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
equal(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2) {
    return equal(first1, last1, first2, pstl::internal::pstl_equal());
}

// [alg.move]
template< class ExecutionPolicy, class InputIterator, class OutputIterator >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
move(ExecutionPolicy&& exec, InputIterator first, InputIterator last, OutputIterator d_first) {
    using namespace pstl::internal;
    const auto is_vector = is_vectorization_preferred<ExecutionPolicy, InputIterator, OutputIterator>(exec);

    return pattern_walk2_brick(first, last, d_first, [is_vector](InputIterator begin, InputIterator end, OutputIterator res) {
        return brick_move(begin, end, res, is_vector);
    }, is_parallelization_preferred<ExecutionPolicy, InputIterator, OutputIterator>(exec));
}

// [partial.sort]

template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
partial_sort(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp) {
    using namespace pstl::internal;
    pattern_partial_sort(first, middle, last, comp,
        is_vectorization_preferred<ExecutionPolicy, RandomAccessIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, RandomAccessIterator>(exec));
}

template<class ExecutionPolicy, class RandomAccessIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
partial_sort(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last) {
    partial_sort(std::forward<ExecutionPolicy>(exec), first, middle, last, pstl::internal::pstl_less());
}

// [partial.sort.copy]

template<class ExecutionPolicy, class InputIterator, class RandomAccessIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, RandomAccessIterator>
partial_sort_copy(ExecutionPolicy&& exec, InputIterator first, InputIterator last, RandomAccessIterator d_first, RandomAccessIterator d_last, Compare comp) {
    using namespace pstl::internal;
    return pattern_partial_sort_copy(first, last, d_first, d_last, comp,
        is_vectorization_preferred<ExecutionPolicy, InputIterator, RandomAccessIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator, RandomAccessIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator, class RandomAccessIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, RandomAccessIterator>
partial_sort_copy(ExecutionPolicy&& exec, InputIterator first, InputIterator last, RandomAccessIterator d_first, RandomAccessIterator d_last) {
    return partial_sort_copy(std::forward<ExecutionPolicy>(exec), first, last, d_first, d_last, pstl::internal::pstl_less());
}

// [is.sorted]
template<class ExecutionPolicy, class ForwardIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
is_sorted_until(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Compare comp) {
    using namespace pstl::internal;
    const ForwardIterator res = pattern_adjacent_find(first, last, pstl::internal::reorder_pred<Compare>(comp),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec), /*first_semantic*/ false);
    return res==last ? last : std::next(res);
}

template<class ExecutionPolicy, class ForwardIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
is_sorted_until(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last) {
    return is_sorted_until(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::pstl_less());
}

template<class ExecutionPolicy, class ForwardIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
is_sorted(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Compare comp) {
    using namespace pstl::internal;
    return pattern_adjacent_find(first, last, reorder_pred<Compare>(comp),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec), /*or_semantic*/ true)==last;
}

template<class ExecutionPolicy, class ForwardIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
is_sorted(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last) {
    return is_sorted(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::pstl_less());
}

// [alg.nth.element]

template<class ExecutionPolicy, class RandomAccessIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
nth_element(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp) {
    using namespace pstl::internal;
    pattern_nth_element(first, nth, last, comp,
        is_vectorization_preferred<ExecutionPolicy, RandomAccessIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, RandomAccessIterator>(exec));
}

template<class ExecutionPolicy, class RandomAccessIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
nth_element(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last) {
    nth_element(std::forward<ExecutionPolicy>(exec), first, nth, last, pstl::internal::pstl_less());
}

// [alg.merge]
template< class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
merge(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator d_first, Compare comp) {
    using namespace pstl::internal;
    return pattern_merge(first1, last1, first2, last2, d_first, comp,
        is_vectorization_preferred<ExecutionPolicy, InputIterator1, InputIterator2, OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator1, InputIterator2, OutputIterator>(exec));
}

template< class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
merge(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator d_first) {
    return merge(std::forward<ExecutionPolicy>(exec), first1, last1, first2, last2, d_first, pstl::internal::pstl_less());
}

template< class ExecutionPolicy, class BidirectionalIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
inplace_merge(ExecutionPolicy&& exec, BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp) {
    using namespace pstl::internal;
    pattern_inplace_merge(first, middle, last, comp,
        is_vectorization_preferred<ExecutionPolicy, BidirectionalIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, BidirectionalIterator>(exec));
}

template< class ExecutionPolicy, class BidirectionalIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, void>
inplace_merge(ExecutionPolicy&& exec, BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {
    inplace_merge(std::forward<ExecutionPolicy>(exec), first, middle, last, pstl::internal::pstl_less());
}

// [includes]

template< class ExecutionPolicy, class InputIterator1, class InputIterator2, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
includes(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp) {
    using namespace pstl::internal;
    return pattern_includes(first1, last1, first2, last2, comp,
        is_vectorization_preferred<ExecutionPolicy, InputIterator1, InputIterator2>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator1, InputIterator2>(exec));
}

template< class ExecutionPolicy, class InputIterator1, class InputIterator2>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
includes(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2) {
    return includes(std::forward<ExecutionPolicy>(exec), first1, last1, first2, last2, pstl::internal::pstl_less());
}

// [set.union]

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
set_union(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp) {
    using namespace pstl::internal;
    return pattern_set_union(first1, last1, first2, last2, result, comp,
        is_vectorization_preferred<ExecutionPolicy, InputIterator1, InputIterator2, OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator1, InputIterator2, OutputIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
set_union(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,
    InputIterator2 last2, OutputIterator result) {
    return set_union(std::forward<ExecutionPolicy>(exec), first1, last1, first2, last2, result, pstl::internal::pstl_less());
}

// [set.intersection]

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
set_intersection(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp) {
    using namespace pstl::internal;
    return pattern_set_intersection(first1, last1, first2, last2, result, comp,
        is_vectorization_preferred<ExecutionPolicy, InputIterator1, InputIterator2, OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator1, InputIterator2, OutputIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
set_intersection(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result) {
    return set_intersection(std::forward<ExecutionPolicy>(exec), first1, last1, first2, last2, result, pstl::internal::pstl_less());
}

// [set.difference]

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
set_difference(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp) {
    using namespace pstl::internal;
    return pattern_set_difference(first1, last1, first2, last2, result, comp,
        is_vectorization_preferred<ExecutionPolicy, InputIterator1, InputIterator2, OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator1, InputIterator2, OutputIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
set_difference(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result) {
    return set_difference(std::forward<ExecutionPolicy>(exec), first1, last1, first2, last2, result, pstl::internal::pstl_less());
}

// [set.symmetric.difference]

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator, class Compare>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
set_symmetric_difference(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp) {
    using namespace pstl::internal;
    return pattern_set_symmetric_difference(first1, last1, first2, last2, result, comp,
        is_vectorization_preferred<ExecutionPolicy, InputIterator1, InputIterator2, OutputIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator1, InputIterator2, OutputIterator>(exec));
}

template<class ExecutionPolicy, class InputIterator1, class InputIterator2, class OutputIterator>
pstl::internal::enable_if_execution_policy<ExecutionPolicy, OutputIterator>
set_symmetric_difference(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result) {
    return set_symmetric_difference(std::forward<ExecutionPolicy>(exec), first1, last1, first2, last2, result, pstl::internal::pstl_less());
}

// [is.heap]
// According to standard:
// A heap is a particular organization of elements in a range between two random access iterators
// [a, b) such that with N = b - a, for all i, 0 < i < N, comp(a[(i-1)/2], a[i]) is false
template< class ExecutionPolicy, class RandomAccessIterator, class Compare >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, RandomAccessIterator>
is_heap_until(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
    using namespace pstl::internal;
    return pattern_is_heap_until(first, last, comp,
        is_vectorization_preferred<ExecutionPolicy, RandomAccessIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, RandomAccessIterator>(exec));
}

template< class ExecutionPolicy, class RandomAccessIterator >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, RandomAccessIterator>
is_heap_until(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator last) {
    return is_heap_until(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::pstl_less());
}

template< class ExecutionPolicy, class RandomAccessIterator, class Compare >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
is_heap(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator last, Compare comp) {
    using namespace pstl::internal;
    return pattern_is_heap_until(first, last, comp,
        is_vectorization_preferred<ExecutionPolicy, RandomAccessIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, RandomAccessIterator>(exec)) == last;
}

template< class ExecutionPolicy, class RandomAccessIterator >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
is_heap(ExecutionPolicy&& exec, RandomAccessIterator first, RandomAccessIterator last) {
    return is_heap(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::pstl_less());
}

// [alg.min.max]

template< class ExecutionPolicy, class ForwardIterator, class Compare >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
min_element(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Compare comp) {
    using namespace pstl::internal;
    return pattern_min_element(first, last, comp,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template< class ExecutionPolicy, class ForwardIterator >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
min_element(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last) {
    return min_element(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::pstl_less());
}

template< class ExecutionPolicy, class ForwardIterator, class Compare >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
max_element(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Compare comp) {
    using namespace pstl::internal;
    return pattern_min_element(first, last, pstl::internal::reorder_pred<Compare>(comp),
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template< class ExecutionPolicy, class ForwardIterator >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, ForwardIterator>
max_element(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last) {
    using namespace pstl::internal;
    return min_element(std::forward<ExecutionPolicy>(exec), first, last, reorder_pred<pstl_less>(pstl_less()));
}

template< class ExecutionPolicy, class ForwardIterator, class Compare >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, std::pair<ForwardIterator, ForwardIterator>>
minmax_element(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last, Compare comp) {
    using namespace pstl::internal;
    return pattern_minmax_element(first, last, comp,
        is_vectorization_preferred<ExecutionPolicy, ForwardIterator>(exec),
        is_parallelization_preferred<ExecutionPolicy, ForwardIterator>(exec));
}

template< class ExecutionPolicy, class ForwardIterator >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, std::pair<ForwardIterator, ForwardIterator>>
minmax_element(ExecutionPolicy&& exec, ForwardIterator first, ForwardIterator last) {
    return minmax_element(std::forward<ExecutionPolicy>(exec), first, last, pstl::internal::pstl_less());
}

// [alg.lex.comparison]

template< class ExecutionPolicy, class InputIterator1, class InputIterator2, class Compare >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
lexicographical_compare(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp) {
    using namespace pstl::internal;
    return pattern_lexicographical_compare(first1, last1, first2, last2, comp,
        is_vectorization_preferred<ExecutionPolicy, InputIterator1, InputIterator2>(exec),
        is_parallelization_preferred<ExecutionPolicy, InputIterator1, InputIterator2>(exec));
}

template< class ExecutionPolicy, class InputIterator1, class InputIterator2 >
pstl::internal::enable_if_execution_policy<ExecutionPolicy, bool>
lexicographical_compare(ExecutionPolicy&& exec, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2) {
    return lexicographical_compare(std::forward<ExecutionPolicy>(exec), first1, last1, first2, last2, pstl::internal::pstl_less());
}

} // namespace std

#endif /* __PSTL_algorithm */
